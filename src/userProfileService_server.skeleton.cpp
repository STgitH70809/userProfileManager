// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "userProfileService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/protocol/TJSONProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/transport/TBufferTransports.h>
#include <map>
#include <iostream>
#include <mutex>
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class userProfileServiceHandler : virtual public userProfileServiceIf {
 public:
     int newID;
     std::mutex mutexUpdate;
     std::map<int , userProfile> users;
     
  void initProfile(){
    for(int i = 0; i < 10 ; i++){
        userProfile profile("client" + std::to_string(i),"Nam",i,i,1990 + i);
        userProfileResult ret;
        Create(ret,profile);
    }
  }
  userProfileServiceHandler() {
      newID = 0;
      initProfile();
  }

  void Create(userProfileResult& _return, const userProfile& profile) {
      userProfile newProfile(profile);
      mutexUpdate.lock();
      newProfile.id = newID++;
      users.insert( std::pair<int , userProfile>(newProfile.id,newProfile));
      mutexUpdate.unlock();
      _return.profile = newProfile;
      _return.errorCode = 0;
      printf("Create\n");
  }

  void Get(userProfileResult& _return, const int32_t id) {
      try{
            mutexUpdate.lock();
            _return.profile = users.at(id);
            mutexUpdate.unlock();
            _return.errorCode = 0;
      }catch(std::out_of_range e){
            mutexUpdate.unlock();
            _return.errorCode = 1;
      }
      printf("Get\n");
  }

  int32_t Update(const int32_t id, const userProfile& newProfile) {
      if(users.count(id) == 0){
          return 1;
      }
      mutexUpdate.lock();
      users.erase(id);
      userProfile profile(newProfile);
      profile.id = id;
      users.insert( std::pair<int , userProfile>(profile.id,profile));
      mutexUpdate.unlock();
      printf("Update\n");
      return 0;
  }

  int32_t Delete(const int32_t id) {
      mutexUpdate.lock();
      users.erase(id);
      mutexUpdate.lock();
      printf("Delete\n");
      return 0;
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::apache::thrift::stdcxx::shared_ptr<userProfileServiceHandler> handler(new userProfileServiceHandler());
  ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new userProfileServiceProcessor(handler));
  ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TFramedTransportFactory());
  ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  std::cout << "___________________________" << std::endl
                  << "Enter 1 for TSimpleServer:" << std::endl
                  << "Enter 2 for TThreadServer:" << std::endl
                  << "Enter 3 for TThreadPoolServer:" << std::endl
                  << "Enter 4 for TNonBlockingServer:" << std::endl
                  << "Enter other number to quit:" << std::endl;
  int choose;
  std::cin >> choose;
  if(choose == 1){
      TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
      server.serve();
  }
  else if(choose == 2){
      ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::concurrency::PosixThreadFactory> threadFactory = 
              ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::concurrency::PosixThreadFactory>(new ::apache::thrift::concurrency::PosixThreadFactory());
      TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory,threadFactory);
      server.serve();
  }
  else if(choose == 3) {
      ::apache::thrift::stdcxx::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(8);
      ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::concurrency::PosixThreadFactory> threadFactory = 
              ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::concurrency::PosixThreadFactory>(new ::apache::thrift::concurrency::PosixThreadFactory());
      threadManager->threadFactory(threadFactory);
      threadManager->start();
      TThreadPoolServer server(processor, serverTransport , transportFactory, protocolFactory, threadManager);
      server.serve();
  }
  else if(choose == 4){
      ::apache::thrift::stdcxx::shared_ptr<TNonblockingServerTransport> nonblockserverTransport(new TNonblockingServerSocket(port));
      ::apache::thrift::stdcxx::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(2);
      ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::concurrency::PosixThreadFactory> threadFactory = 
              ::apache::thrift::stdcxx::shared_ptr<::apache::thrift::concurrency::PosixThreadFactory>(new ::apache::thrift::concurrency::PosixThreadFactory());
      threadManager->threadFactory(threadFactory);
      threadManager->start();
      TNonblockingServer server(processor, protocolFactory,nonblockserverTransport, threadManager);
      server.setNumIOThreads(2);
      server.serve();
  }
          
  
  return 0;
}

